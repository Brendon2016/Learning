# 继承与派生
代码复用，基类的所有成员（除构造和析构函数）全部被派生类继承。可同时继承多个类：
```
class 派生类名：继承方式 基类名1，继承方式 基类名2...
class Derived:public Base1, private Base2
```
## 生成过程
- 吸收基类成员：按继承顺序调用基类构造函数
- 改造基类成员：覆盖隐藏同名成员
- 添加新成员：执行派生类构造函数
## 访问控制
继承方式可以为public、private、protect，三种继承方式只改变派生类中基类成员的访问属性
## 类型兼容
基类指针可以指向派生类对象，但该指针只能访问派生类中基类的部分，相当于派生类只起基类的作用。若想访问派生类的其他部分，可用多态--虚函数。
## 虚基类
可以理解为，通过虚继承的成员都保存在基类中，而不是派生类中，因此通过多条路径虚继承同一个基类时，得到的基类成员只有一个副本。正常继承时，多条路径继承同一个基类时，基类成员多个副本。
# 多态  
同样的消息（参数）被不同类型的对象接收时进行不同的处理。
1. 运算符重载
- 重载为类成员函数  
运算符的第一个参数为调用重载函数的类，剩下的参数由形参指定。
```
返回类型 operator 运算符（参数表）
base operator+(const base &c2) const;

```
- 重载为非类成员函数  
运算符的全部参数由形参指定。如需访问类的私有成员时，可将其声明为类的友元函数。
2. 虚函数  
××通过基类指针访问派生类时××，正常只能访问派生类的基类成员，而不能访问派生类自身新增的成员，因此将基类成员函数声明为虚函数，此时即可访问派生类的成员函数。
```
virtual 函数类型 函数名（形参表）;
virtul void display() const
{
}
```
3.纯虚函数  
与虚函数不同的时，纯虚函数在声明时无法实现，即不能写出函数体，此时可用纯虚函数，一般作为接口使用，有纯虚函数的类为抽象类。××抽象类不能实例化，因此纯虚函数没有实现。××
```
virtual 函数类型 函数名（形参表）=0;
virtul void display()=0
```
# 泛型
编写程序时，不依赖与具体数据类型。定义模板之后，在之后使用模板时，自动推导模板类型
- 声明模板
```
template <class T>
template <typename T>
```
- 使用模板类型
```
void swap(T &a, T &b) {
    T temp;
    temp = a;
    a = b;
    b = temp;
}
```
- 调用带模板类型的函数
```
swap(a, b); 		//自动推导a,b类型
swap<int>(a, b);        //显示指定模板类型为int

```
# C++11 [新特性](https://www.kancloud.cn/wangshubo1989/new-characteristics/99703)
1. auto关键字
自动推断类型，注意不能用来声明函数的返回值。
2. nullptr
用来指代空指针。nullptr和任何指针类型以及类成员指针类型的空值之间可以发生隐式类型转换，同样也可以隐式转换为bool型（取值为false）。但是不存在到整形的隐式类型转换。
3. for的高级用法
```
for(const auto& kvp : map)    //遍历map的所有成员
```

