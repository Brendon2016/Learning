# Basic usage
1. Minimum Version
```
cmake_minimum_required(VERSION 3.1)；
```
2. Setting a project like project name and descriptions:
```
project(MyProject 					# project name
	VERSION 1.0					# optional, project version
	DESCRIPTION "Very nice project"			# optional, project description
	LANGUAGES CXX)					# optional, the languages used, it can be C,CXX and so on
```
3. find directories for libraries which shall be linked later
```
find_package(PackageName REQUIRED COMPONENTS          	# 必须在step4.5.6之前执行
  components
)

link_directories(libdirectories)  			# 必须在step4.5.6之前执行
```
4. Including directories
* Including directories only for a specified target
```
target_include_directories(one 				# executable file name which needs to include directories
	PUBLIC 
	include)					# include path
```
* Including directories for add target
```
include_directories(					# caution, it must noe specify a target name
	PUBLIC 
	include)					# include path
```
5. Making an executable
```
add_executable(one					# executable file name which is going to generated by cmake
	two.cpp 					# source file
	three.h)					# header file, caution, header file will be ignored
```
6. Linking a library
```
target_link_libraries(one 				# executable file name
	PUBLIC 						# 
	two)						# library name
```
**caution:when you need to use a library, you should link the library and include its include path**  
7. Making a library
```
add_library(one 					# library name which is going to be generated
	STATIC 						# library type which can be STATIC,SHARED,MODELE
	two.cpp
	three.h)
``
# Variables
1. set variables
```
set(MY_VARIABLE "value")
set(MY_LIST "one" "two")
```
2. access variables
```
${MY_VARIABLE}
```
3. set property
```
set_property(TARGET TargetName
             PROPERTY CXX_STANDARD 11)
```
4. common used properties
```
# 设置可执行文件的输出路径(EXCUTABLE_OUTPUT_PATH是全局变量)
set(EXECUTABLE_OUTPUT_PATH [output_path])
# 设置库文件的输出路径(LIBRARY_OUTPUT_PATH是全局变量)
set(LIBRARY_OUTPUT_PATH [output_path])
# 设置C++编译参数(CMAKE_CXX_FLAGS是全局变量)
set(CMAKE_CXX_FLAGS "-Wall std=c++11")
# 设置源文件集合(SOURCE_FILES是本地变量即自定义变量)
set(SOURCE_FILES main.cpp test.cpp ...)
```
# Running a command
1. find packages
```
find_package(Caffe REQUIRED)				# the parkage name which is going to find

if (NOT Caffe_FOUND)					# check if it has been found , if the package has been found, there will generate several
    message(FATAL_ERROR "Caffe Not Found!")		# variables like Caffe_INCLUDE_DIRS , Caffe_LIBRARIES
endif (NOT Caffe_FOUND)

```
# 编译过程：
test.c->test.i->test.s->test.o->test.exe
- Libraries are by default looked for in /lib, /usr/lib and the directories specified by /etc/ld.so.conf
- LD_LIBRARY_PATH="your/boost/directory"
# 如何知道一个可执行程序依赖哪些库
ldd命令可以查看一个可执行程序依赖的共享库，
例如# ldd /bin/lnlibc.so.6
=> /lib/libc.so.6 (0×40021000)/lib/ld-linux.so.2
=> /lib/ld- linux.so.2 (0×40000000)
可以看到ln命令依赖于libc库和ld-linux库
# 可执行程序在执行的时候如何定位共享库文件
当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路径
此时就需要系统动态载入器(dynamic linker/loader)
对于elf格式的可执行程序，是由ld-linux.so*来完成的
它先后搜索elf文件的 DT_RPATH段—环境变量LD_LIBRARY_PATH—/etc/ld.so.cache文件列表—/lib/,/usr/lib目录
找到库文件后将其载入内存
# 在新安装一个库之后如何让系统能够找到它
如果安装在/lib或者/usr/lib下，那么ld默认能够找到，无需其他操作。
如果安装在其他目录，需要将其添加到/etc/ld.so.cache文件中，步骤如下
1.编辑/etc/ld.so.conf文件，加入库文件所在目录的路径
2.运行ldconfig，该命令会重建/etc/ld.so.cache文件
